<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlueprintSvcLogicService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">blueprintsprocessor</a> &gt; <a href="index.source.html" class="el_package">org.onap.ccsdk.cds.blueprintsprocessor.services.workflow</a> &gt; <span class="el_source">BlueprintSvcLogicService.kt</span></div><h1>BlueprintSvcLogicService.kt</h1><pre class="source lang-java linenums">/*
 * Copyright © 2017-2018 AT&amp;T Intellectual Property.
 * Modifications Copyright © 2019 IBM.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onap.ccsdk.cds.blueprintsprocessor.services.workflow

import org.onap.ccsdk.cds.controllerblueprints.core.service.BluePrintRuntimeService
import org.onap.ccsdk.sli.core.sli.*
import org.onap.ccsdk.sli.core.sli.provider.base.*
import org.slf4j.LoggerFactory
import org.slf4j.MDC
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.ApplicationContext
import org.springframework.stereotype.Service
import java.util.*
import javax.annotation.PostConstruct

interface BlueprintSvcLogicService : SvcLogicServiceBase {

    fun registerDefaultExecutors()

    fun registerExecutors(name: String, svcLogicNodeExecutor: AbstractSvcLogicNodeExecutor)

    fun unRegisterExecutors(name: String)

    suspend fun execute(graph: SvcLogicGraph, bluePrintRuntimeService: BluePrintRuntimeService&lt;*&gt;, input: Any): Any

    @Deprecated(&quot;Populate Graph Dynamically from Blueprints, No need to get from Database Store &quot;)
    override fun getStore(): SvcLogicStore {
<span class="nc" id="L43">        TODO(&quot;not implemented&quot;)</span>
    }

    @Deprecated(&quot;Not used in Micro service Implementation&quot;)
    override fun hasGraph(module: String, rpc: String, version: String?, mode: String): Boolean {
<span class="nc" id="L48">        TODO(&quot;not implemented&quot;)</span>
    }

    @Deprecated(&quot;Not used in Micro service Implementation&quot;)
    override fun execute(p0: String?, p1: String?, p2: String?, p3: String?, p4: Properties?): Properties {
<span class="nc" id="L53">        TODO(&quot;not implemented&quot;)</span>
    }
}


@Service
<span class="pc" id="L59">class DefaultBlueprintSvcLogicService : BlueprintSvcLogicService {</span>

<span class="fc" id="L61">    private val log = LoggerFactory.getLogger(DefaultBlueprintSvcLogicService::class.java)</span>

<span class="fc" id="L63">    private val nodeExecutors: MutableMap&lt;String, AbstractSvcLogicNodeExecutor&gt; = hashMapOf()</span>

    @Autowired
    private lateinit var context: ApplicationContext

    @PostConstruct
    override fun registerDefaultExecutors() {

<span class="fc" id="L71">        val executeNodeExecutor = context.getBean(ExecuteNodeExecutor::class.java)</span>
<span class="fc" id="L72">        registerExecutors(&quot;execute&quot;, executeNodeExecutor)</span>
<span class="fc" id="L73">        registerExecutors(&quot;block&quot;, BlockNodeExecutor())</span>
<span class="fc" id="L74">        registerExecutors(&quot;return&quot;, ReturnNodeExecutor())</span>
<span class="fc" id="L75">        registerExecutors(&quot;break&quot;, BreakNodeExecutor())</span>
<span class="fc" id="L76">        registerExecutors(&quot;exit&quot;, ExitNodeExecutor())</span>
<span class="fc" id="L77">    }</span>

    override fun registerExecutors(name: String, svcLogicNodeExecutor: AbstractSvcLogicNodeExecutor) {
<span class="fc" id="L80">        log.debug(&quot;Registering executors($name) with type(${svcLogicNodeExecutor.javaClass}&quot;)</span>
<span class="fc" id="L81">        nodeExecutors[name] = svcLogicNodeExecutor</span>
<span class="fc" id="L82">    }</span>

    override fun unRegisterExecutors(name: String) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (nodeExecutors.containsKey(name)) {</span>
<span class="nc" id="L86">            log.info(&quot;UnRegistering executors($name)&quot;)</span>
<span class="nc" id="L87">            nodeExecutors.remove(name)</span>
        }
<span class="nc" id="L89">    }</span>

    override suspend fun execute(graph: SvcLogicGraph, bluePrintRuntimeService: BluePrintRuntimeService&lt;*&gt;,
                                 input: Any): Any {
        //Initialise BlueprintSvcLogic Context with Blueprint Runtime Service and Input Request
<span class="fc" id="L94">        val blueprintSvcLogicContext = BlueprintSvcLogicContext()</span>
<span class="fc" id="L95">        blueprintSvcLogicContext.setBluePrintRuntimeService(bluePrintRuntimeService)</span>
<span class="fc" id="L96">        blueprintSvcLogicContext.setRequest(input)</span>
        // Execute the Graph
<span class="fc" id="L98">        execute(graph, blueprintSvcLogicContext)</span>
        // Get the Response
<span class="fc" id="L100">        return blueprintSvcLogicContext.getResponse()</span>
    }

    override fun executeNode(node: SvcLogicNode?, ctx: SvcLogicContext): SvcLogicNode? {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L105">            return null</span>
        } else {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            if (log.isDebugEnabled) {</span>
<span class="nc" id="L108">                log.debug(&quot;Executing node {}&quot;, node.nodeId)</span>
            }

<span class="fc" id="L111">            val executor = this.nodeExecutors[node.nodeType]</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (executor != null) {</span>
<span class="fc" id="L114">                log.debug(&quot;Executing node executor for node type {} - {}&quot;, node.nodeType, executor.javaClass.name)</span>
<span class="fc" id="L115">                return executor.execute(this, node, ctx)</span>
            } else {
<span class="nc" id="L117">                throw SvcLogicException(&quot;Attempted to execute a node of type &quot; + node.nodeType + &quot;, but no executor was registered for this type&quot;)</span>
            }
        }
    }

    override fun execute(graph: SvcLogicGraph, svcLogicContext: SvcLogicContext): SvcLogicContext {
<span class="fc" id="L123">        MDC.put(&quot;currentGraph&quot;, graph.toString())</span>

<span class="fc" id="L125">        var curNode: SvcLogicNode? = graph.rootNode</span>
<span class="fc" id="L126">        log.info(&quot;About to execute graph {}&quot;, graph.toString())</span>

<span class="fc" id="L128">        try {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            while (curNode != null) {</span>
<span class="fc" id="L130">                MDC.put(&quot;nodeId&quot;, curNode.nodeId.toString() + &quot; (&quot; + curNode.nodeType + &quot;)&quot;)</span>
<span class="fc" id="L131">                log.info(&quot;About to execute node # {} ({})&quot;, curNode.nodeId, curNode.nodeType)</span>
<span class="fc" id="L132">                val nextNode = this.executeNode(curNode, svcLogicContext)</span>
<span class="fc" id="L133">                curNode = nextNode</span>
            }
<span class="nc" id="L135">        } catch (var5: ExitNodeException) {</span>
<span class="nc" id="L136">            log.debug(&quot;SvcLogicServiceImpl caught ExitNodeException&quot;)</span>
        }

<span class="fc" id="L139">        MDC.remove(&quot;nodeId&quot;)</span>
<span class="fc" id="L140">        MDC.remove(&quot;currentGraph&quot;)</span>
<span class="fc" id="L141">        return svcLogicContext</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>